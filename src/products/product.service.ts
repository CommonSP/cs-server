import {Injectable} from '@nestjs/common'import {InjectRepository} from '@nestjs/typeorm'import {Like, MoreThan, Repository} from 'typeorm'import {GetProductsDto} from './dto/get-products-dto'import {Product} from './product.entity'@Injectable()export class ProductService {	constructor(@InjectRepository(Product) private productRepository: Repository<Product>) {	}	getProducts(params: GetProductsDto) {		switch (params.mainCategory) {			case 'Смесители для ванной комнаты и душевых кабин':				if (params.subCategory) {					switch (params.subCategory) {						case 'Ванна стационарный однорукояточный':							return this.productRepository.findAndCount({								where: {									nasnacheniy: Like(`%Ванна стационарный%`),									price: MoreThan(0),									upravlenie: Like(`%Однорукояточное%`),								},								skip: Number(params.offset),								take: Number(params.limit),								order: {									guid: 'ASC'								},								relations: {images: true}							})						case 'Ванна стационарный двухрукояточный':							return this.productRepository.findAndCount({								where: {									nasnacheniy: Like(`%Ванна стационарный%`),									price: MoreThan(0),									upravlenie: Like(`%Двухрукояточное%`),								},								skip: Number(params.offset),								take: Number(params.limit),								order: {									guid: 'ASC'								},								relations: {images: true}							})						default:							return this.productRepository.findAndCount({								where: {									nasnacheniy: Like(`%${params.subCategory}%`),									price: MoreThan(0),								},								skip: Number(params.offset),								take: Number(params.limit),								order: {									guid: 'ASC'								},								relations: {images: true}							})					}				} else {					return this.productRepository.findAndCount({						where: [							{								nasnacheniy: Like(`%Ванна двухрукояточный%`),								price: MoreThan(0),							},							{								nasnacheniy: Like(`%Ванна литой корпус%`),								price: MoreThan(0),							},							{								nasnacheniy: Like(`%Ванна однорукояточный%`),								price: MoreThan(0),							},							{								nasnacheniy: Like(`%Ванна с дайвотером%`),								price: MoreThan(0),							},							{								nasnacheniy: Like(`%Ванна стационарный%`),								price: MoreThan(0),							},						],						skip: Number(params.offset),						take: Number(params.limit),						order: {							guid: 'ASC'						},						relations: {images: true}					})				}			case 'Гибкие соединения':				if (params.subCategory) {					return this.productRepository.findAndCount({						where: {							nasnacheniy: params.subCategory,							price: MoreThan(0),						},						skip: Number(params.offset),						take: Number(params.limit),						order: {							guid: 'ASC'						},						relations: {images: true}					})				} else {					return this.productRepository.findAndCount({						where: [							{								nasnacheniy: 'Гигант',								price: MoreThan(0),							},							{								nasnacheniy: 'Для воды',								price: MoreThan(0),							},							{								nasnacheniy: 'Для смесителя',								price: MoreThan(0),							},							{								nasnacheniy: 'Заливной',								price: MoreThan(0),							},						],						skip: Number(params.offset),						take: Number(params.limit),						order: {							guid: 'ASC'						},						relations: {images: true}					})				}			case 'Комплектация':				if (params.subCategory) {					return this.productRepository.findAndCount({						where: {							nasnacheniy: params.subCategory,							price: MoreThan(0),						},						skip: Number(params.offset),						take: Number(params.limit),						order: {							guid: 'ASC'						},						relations: {images: true}					})				} else {					return this.productRepository.findAndCount({						where: [							{								nasnacheniy: 'РТИ',								price: MoreThan(0),							},							{								nasnacheniy: 'Маховики и ручки',								price: MoreThan(0),							},							{								nasnacheniy: 'Механизмы управления',								price: MoreThan(0),							},							{								nasnacheniy: 'Лейки и насадки для душа',								price: MoreThan(0),							},							{								nasnacheniy: 'Изливы',								price: MoreThan(0),							},							{								nasnacheniy: 'Другое',								price: MoreThan(0),							},						],						skip: Number(params.offset),						take: Number(params.limit),						order: {							guid: 'ASC'						},						relations: {images: true}					})				}			case 'Душевая система':				return this.productRepository.findAndCount({					where: {						nasnacheniy: params.mainCategory,						price: MoreThan(0),					},					skip: Number(params.offset),					take: Number(params.limit),					order: {						guid: 'ASC'					},					relations: {images: true}				})			case 'Душевая стойка':				return this.productRepository.findAndCount({					where: {						nasnacheniy: params.mainCategory,						price: MoreThan(0),					},					skip: Number(params.offset),					take: Number(params.limit),					order: {						guid: 'ASC'					},					relations: {images: true}				})			case 'Шланг душевой':				return this.productRepository.findAndCount({					where: {						nasnacheniy: params.mainCategory,						price: MoreThan(0),					},					skip: Number(params.offset),					take: Number(params.limit),					order: {						guid: 'ASC'					},					relations: {images: true}				})			default:				return this.productRepository.findAndCount({					where: {						nasnacheniy: params.mainCategory,						upravlenie: Like(`%${params.subCategory}%`),						price: MoreThan(0),					},					skip: Number(params.offset),					take: Number(params.limit),					order: {						guid: 'ASC'					},					relations: {images: true}				})		}	}	getProductById(id: string) {		return this.productRepository.findOne(			{				where: {guid: id},				relations: {images: true}			})	}	async getProductByArticle(article: string) {		return this.productRepository.findAndCount({			where: {articul: Like(`%${article}%`)},			take: 10,		})	}	async updateProductById(id: string, data: any) {		return this.productRepository.update({guid: id}, data)	}}